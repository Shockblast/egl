/*
Copyright (C) 1997-2001 Id Software, Inc.

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
*/

//
// cg_local.h
// CGame local header
//

#ifndef __CGAME_LOCAL_H__
#define __CGAME_LOCAL_H__

#include "../shared/shared.h"
#include "../ui/keycodes.h"
#include "cg_api.h"

extern cgImport_t cgi;

#define HUD_SCALE		(r_hudscale->value)
#define HUD_FTSIZE		(8.0f * HUD_SCALE)

/*
==================================================================

	API

==================================================================
*/

#define CG_MemAlloc(size)	cgi.Mem_Alloc((size),__FILE__,__LINE__)
#define CG_MemFree(ptr)		cgi.Mem_Free((ptr),__FILE__,__LINE__)

/*
==================================================================

	CGAME STATE

==================================================================
*/

typedef struct clientInfo_s {
	char				name[MAX_QPATH];
	char				cInfo[MAX_QPATH];
	struct image_s		*skin;
	struct image_s		*icon;
	char				iconName[MAX_QPATH];
	struct model_s		*model;
	struct model_s		*weaponModel[MAX_CLIENTWEAPONMODELS];
} clientInfo_t;

typedef struct cgState_s {
	qBool				initialized;				// true if cgame was initialized

	// time
	int					time;

	float				lerpFrac;					// between oldframe and frame

	refDef_t			refDef;
	vec3_t				v_Forward, v_Right, v_Up;	// set when refdef.angles is set

	// the client maintains its own idea of view angles, which are
	// sent to the server each frame. It is cleared to 0 upon entering each level.
	// the server sends a delta each frame which is added to the locally
	// tracked view angles to account for standing on rotating objects,
	// and teleport direction changes
	vec3_t				viewAngles;

	float				predictedStep;				// for stair up smoothing
	uInt				predictedStepTime;
	short				predictedOrigins[CMD_BACKUP][3];	// for debug comparing against server
	vec3_t				predictedOrigin;			// generated by CG_PredictMovement
	vec3_t				predictedAngles;
	vec3_t				predictedVelocity;
	vec3_t				predictionError;

	frame_t				frame;						// received from server
	frame_t				oldFrame;

	qBool				attractLoop;

	int					playerNum;

	char				configStrings[MAX_CONFIGSTRINGS][MAX_QPATH];

	//
	// video dimensions
	//
	int					vidWidth;
	int					vidHeight;

	//
	// hud and inventory
	//
	char				layout[1024];				// general 2D overlay
	int					inventory[MAX_CS_ITEMS];

	//
	// locally derived information from server state
	//
	struct model_s		*modelDraw[MAX_CS_MODELS];
	struct cBspModel_s	*modelClip[MAX_CS_MODELS];

	clientInfo_t		clientInfo[MAX_CS_CLIENTS];
	clientInfo_t		baseClientInfo;
} cgState_t;

extern cgState_t	cg;

/*
==================================================================

	CONNECTION

==================================================================
*/

typedef struct cgStatic_s {
	int				frameCount;
	float			frameTime;

	int				realTime;
} cgStatic_t;

extern cgStatic_t	cgs;

/*
==================================================================

	LIGHTING

==================================================================
*/

typedef struct cgDlight_s {
	vec3_t		origin;
	vec3_t		color;

	int			key;				// so entities can reuse same entry

	float		radius;
	float		die;				// stop lighting after this time
	float		decay;				// drop this each second
	float		minlight;			// don't add when contributing less
} cgDLight_t;

//
// cg_light.c
//

void	CG_ClearLightStyles (void);
cgDLight_t *CG_AllocDLight (int key);
void	CG_RunLightStyles (void);
void	CG_SetLightstyle (int num);
void	CG_AddLightStyles (void);

void	CG_ClearDLights (void);
void	CG_RunDLights (void);
void	CG_AddDLights (void);

void	CG_Flashlight (int ent, vec3_t pos);
void	FASTCALL CG_ColorFlash (vec3_t pos, int ent, int intensity, float r, float g, float b);
void	CG_WeldingSparkFlash (vec3_t pos);

/*
==================================================================

	ENTITY

==================================================================
*/

typedef struct cgEntity_s {
	entityState_t	baseLine;		// delta from this if not from a previous frame
	entityState_t	current;
	entityState_t	prev;			// will always be valid, but might just be a copy of current

	int				serverFrame;		// if not current, this ent isn't in the frame

	vec3_t			lerpOrigin;		// for trails (variable hz)

	int				flyStopTime;

	qBool			muzzleOn;
	int				muzzType;
	qBool			muzzSilenced;
	qBool			muzzVWeap;
} cgEntity_t;

extern cgEntity_t		cgEntities[MAX_CS_EDICTS];

// the cgParseEntities must be large enough to hold UPDATE_BACKUP frames of
// entities, so that when a delta compressed message arives from the server
// it can be un-deltad from the original
extern entityState_t	cgParseEntities[MAX_PARSE_ENTITIES];

//
// cg_entities.c
//

void	CG_BeginFrameSequence (frame_t frame);
void	CG_NewPacketEntityState (int entnum, entityState_t state);
void	CG_EndFrameSequence (int numEntities);

void	CG_AddEntities (void);
void	CG_ClearEntities (void);

void	CG_GetEntitySoundOrigin (int entNum, vec3_t org);

//
// cg_localents.c
//

void	CG_ClearLocalEnts (void);
void	CG_AddLocalEnts (void);

//
// cg_tempents.c
//

void	CG_ExploRattle (vec3_t org, float scale);

void	CG_AddTempEnts (void);
void	CG_ClearTempEnts (void);
void	CG_ParseTempEnt (void);

//
// cg_weapon.c
//

void	CG_AddViewWeapon (void);

void	CG_WeapRegister (void);
void	CG_WeapUnregister (void);

/*
==============================================================

	PLAYER MOVEMENT

==============================================================
*/

enum {
	GLM_DEFAULT,

	GLM_OBSERVER,
	GLM_BREEDER,
	GLM_HATCHLING,
	GLM_DRONE,
	GLM_WRAITH,
	GLM_KAMIKAZE,
	GLM_STINGER,
	GLM_GUARDIAN,
	GLM_STALKER,
	GLM_ENGINEER,
	GLM_GRUNT,
	GLM_ST,
	GLM_BIOTECH,
	GLM_HT,
	GLM_COMMANDO,
	GLM_EXTERM,
	GLM_MECH
};

//
// pmove.c
// common between the client and server for consistancy
//
void	Pmove (pMove_t *pMove, float airAcceleration);

//
// cg_predict.c
//
void	CG_CheckPredictionError (void);

trace_t	CG_PMTrace (vec3_t start, vec3_t mins, vec3_t maxs, vec3_t end, qBool entities);

void	CG_PredictMovement (void);

/*
==================================================================

	EFFECTS

==================================================================
*/

#ifndef __gl_h_
#ifndef __GL_H__
#define  GL_ZERO						0
#define  GL_ONE							1
#define  GL_SRC_COLOR					0x0300
#define  GL_ONE_MINUS_SRC_COLOR			0x0301
#define  GL_SRC_ALPHA					0x0302
#define  GL_ONE_MINUS_SRC_ALPHA			0x0303
#define  GL_DST_ALPHA					0x0304
#define  GL_ONE_MINUS_DST_ALPHA			0x0305
#define  GL_DST_COLOR					0x0306
#define  GL_ONE_MINUS_DST_COLOR			0x0307
#define  GL_SRC_ALPHA_SATURATE			0x0308
#define  GL_CONSTANT_COLOR				0x8001
#define  GL_ONE_MINUS_CONSTANT_COLOR	0x8002
#define  GL_CONSTANT_ALPHA				0x8003
#define  GL_ONE_MINUS_CONSTANT_ALPHA	0x8004
#endif
#endif

enum {
	// ----------- PARTICLES ----------
	PT_BLUE,
	PT_GREEN,
	PT_RED,
	PT_WHITE,

	PT_SMOKE,
	PT_SMOKE2,

	PT_BLUEFIRE,
	PT_FIRE1,
	PT_FIRE2,
	PT_FIRE3,
	PT_FIRE4,
	PT_EMBERS1,
	PT_EMBERS2,
	PT_EMBERS3,

	PT_BEAM,
	PT_BLDDRIP,
	PT_BUBBLE,
	PT_DRIP,
	PT_EXPLOFLASH,
	PT_EXPLOWAVE,
	PT_FLARE,
	PT_FLY,
	PT_MIST,
	PT_SPARK,
	PT_SPLASH,
	// ----------- ANIMATED -----------
	PT_EXPLO1,
	PT_EXPLO2,
	PT_EXPLO3,
	PT_EXPLO4,
	PT_EXPLO5,
	PT_EXPLO6,
	PT_EXPLO7,

	PT_EXPLOEMBERS1,
	PT_EXPLOEMBERS2,
	// ------------ DECALS ------------
	DT_BLOOD,
	DT_BLOOD2,
	DT_BLOOD3,
	DT_BLOOD4,
	DT_BLOOD5,
	DT_BLOOD6,

	DT_BULLET,
	DT_BURNMARK,

	DT_EXPLOMARK,
	DT_EXPLOMARK2,
	DT_EXPLOMARK3,

	DT_SLASH,
	DT_SLASH2,
	DT_SLASH3,

	// ------------- MAPFX ------------
	MFX_CORONA,
	// ------------- TOTAL ------------
	PDT_PICTOTAL
};

extern vec3_t	avelocities[NUMVERTEXNORMALS];

/*
==================================================================

	SCRIPTED MAP EFFECTS

==================================================================
*/

void	CG_AddMapFX (void);
void	CG_ClearMapFX (void);

void	CG_InitMapFX (char *mapName);
void	CG_ShutdownMapFX (void);

/*
==================================================================

	CGAME MEDIA

==================================================================
*/

typedef struct cgMedia_s {
	qBool			initialized;

	// sounds
	struct sfx_s	*footstepSfx[4];
	struct sfx_s	*ricochetSfx[3];
	struct sfx_s	*sparkSfx[7];

	struct sfx_s	*disruptExploSfx;
	struct sfx_s	*grenadeExploSfx;
	struct sfx_s	*rocketExploSfx;
	struct sfx_s	*waterExploSfx;

	struct sfx_s	*gibSfx;
	struct sfx_s	*itemRespawnSfx;
	struct sfx_s	*laserHitSfx;
	struct sfx_s	*lightningSfx;

	struct sfx_s	*playerFallSfx;
	struct sfx_s	*playerFallShortSfx;
	struct sfx_s	*playerFallFarSfx;

	struct sfx_s	*playerTeleport;
	struct sfx_s	*bigTeleport;

	// muzzleflash sounds
	struct sfx_s	*mzBFGFireSfx;
	struct sfx_s	*mzBlasterFireSfx;
	struct sfx_s	*mzETFRifleFireSfx;
	struct sfx_s	*mzGrenadeFireSfx;
	struct sfx_s	*mzGrenadeReloadSfx;
	struct sfx_s	*mzHyperBlasterFireSfx;
	struct sfx_s	*mzIonRipperFireSfx;
	struct sfx_s	*mzMachineGunSfx[5];
	struct sfx_s	*mzPhalanxFireSfx;
	struct sfx_s	*mzRailgunFireSfx;
	struct sfx_s	*mzRailgunReloadSfx;
	struct sfx_s	*mzRocketFireSfx;
	struct sfx_s	*mzRocketReloadSfx;
	struct sfx_s	*mzShotgunFireSfx;
	struct sfx_s	*mzShotgun2FireSfx;
	struct sfx_s	*mzShotgunReloadSfx;
	struct sfx_s	*mzSuperShotgunFireSfx;
	struct sfx_s	*mzTrackerFireSfx;

	// monster muzzleflash sounds
	struct sfx_s	*mz2ChicRocketSfx;
	struct sfx_s	*mz2FloatBlasterSfx;
	struct sfx_s	*mz2FlyerBlasterSfx;
	struct sfx_s	*mz2GunnerGrenadeSfx;
	struct sfx_s	*mz2GunnerMachGunSfx;
	struct sfx_s	*mz2HoverBlasterSfx;
	struct sfx_s	*mz2JorgMachGunSfx;
	struct sfx_s	*mz2MachGunSfx;
	struct sfx_s	*mz2MakronBlasterSfx;
	struct sfx_s	*mz2MedicBlasterSfx;
	struct sfx_s	*mz2SoldierBlasterSfx;
	struct sfx_s	*mz2SoldierMachGunSfx;
	struct sfx_s	*mz2SoldierShotgunSfx;
	struct sfx_s	*mz2SuperTankRocketSfx;
	struct sfx_s	*mz2TankBlasterSfx;
	struct sfx_s	*mz2TankMachGunSfx[5];
	struct sfx_s	*mz2TankRocketSfx;

	// models
	struct model_s	*parasiteSegmentMOD;
	struct model_s	*grappleCableMOD;

	struct model_s	*lightningMOD;
	struct model_s	*heatBeamMOD;
	struct model_s	*monsterHeatBeamMOD;

	// images
	struct image_s	*crosshairImage;

	struct image_s	*tileBackImage;

	struct image_s	*hudFieldImage;
	struct image_s	*hudInventoryImage;
	struct image_s	*hudNetImage;
	struct image_s	*hudNumImages[2][11];
	struct image_s	*hudPausedImage;

	// particle/decal media
	struct image_s	*mediaTable[PDT_PICTOTAL];
} cgMedia_t;

extern cgMedia_t	cgMedia;

/*
==================================================================

	DECAL SYSTEM

==================================================================
*/

typedef struct cgDecal_s {
	struct		cgDecal_s *next;

	double		time;

	int			numVerts;
	vec2_t		*coords;
	vec3_t		*verts;

	struct		mBspNode_s *node;

	vec3_t		org;
	vec3_t		dir;

	dvec4_t		color;
	dvec4_t		colorVel;

	double		size;
	double		sizeVel;

	double		lifeTime;

	struct		image_s *image;
	int			flags;

	int			sFactor;
	int			dFactor;

	void		(*think)(struct cgDecal_s *d, dvec4_t color, int *type, int *flags);
	qBool		thinkNext;

	double		angle;
} cgDecal_t;

enum {
	DF_NOTIMESCALE	= 1 << 7,
	DF_ALPHACOLOR	= 1 << 8,

	DF_AIRONLY		= 1 << 9,
	DF_LAVAONLY		= 1 << 10,
	DF_SLIMEONLY	= 1 << 11,
	DF_WATERONLY	= 1 << 12
};

cgDecal_t	*makeDecal (double org0,					double org1,					double org2,
						double dir0,					double dir1,					double dir2,
						double red,						double green,					double blue,
						double redVel,					double greenVel,				double blueVel,
						double alpha,					double alphaVel,
						double size,					double sizeVel,
						int type,						int flags,
						int sFactor,					int dFactor,
						void (*think)(struct cgDecal_s *d, dvec4_t color, int *type, int *flags),
						qBool thinkNext,
						double lifeTime,				 double angle);

// constants
#define DECAL_GLOWTIME	( cl_decal_burnlife->value )
#define DECAL_INSTANT	-10000.0

// random texturing
int dRandBloodMark (void);
int dRandExploMark (void);
int dRandSlashMark (void);

// management
void	CG_ClearDecals (void);
void	CG_AddDecals (void);

/*
==================================================================

	PARTICLE SYSTEM

==================================================================
*/

typedef struct cgParticle_s {
	struct		cgParticle_s *next;

	double		time;

	vec3_t		org;
	vec3_t		oldOrigin;

	vec3_t		angle;
	vec3_t		vel;
	vec3_t		accel;

	dvec4_t		color;
	dvec4_t		colorVel;

	double		size;
	double		sizeVel;

	struct		image_s *image;
	int			flags;

	int			sFactor;
	int			dFactor;

	double		orient;

	float		lastSeenTime;
	float		lastKillTime;

	void		(*think)(struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);
	qBool		thinkNext;
} cgParticle_t;

enum {
	PF_SHADE		= 1 << 5,
	PF_GRAVITY		= 1 << 6,
	PF_NODECAL		= 1 << 7,
	PF_ALPHACOLOR	= 1 << 8,

	PF_AIRONLY		= 1 << 9,
	PF_LAVAONLY		= 1 << 10,
	PF_SLIMEONLY	= 1 << 11,
	PF_WATERONLY	= 1 << 12,
	PF_NOCLOSECULL	= 1 << 13
};

void FASTCALL makePart (double org0,					double org1,					double org2,
						double angle0,					double angle1,					double angle2,
						double vel0,					double vel1,					double vel2,
						double accel0,					double accel1,					double accel2,
						double red,						double green,					double blue,
						double redVel,					double greenVel,				double blueVel,
						double alpha,					double alphaVel,
						double size,					double sizeVel,
						int type,						int flags,
						int sFactor,					int dFactor,
						void (*think)(struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time),
						qBool thinkNext,
						double orient);

// constants
#define PMAXBLDRIPLEN	2.75
#define PMAXSPLASHLEN	2.0

#define	PART_GRAVITY	110
#define PART_INSTANT	-10000.0

#define	BEAMLENGTH		16

// random texturing
int		pRandSmoke (void);
int		pRandEmbers (void);
int		pRandFire (void);

// management
qBool	pDegree (vec3_t org, qBool lod);
float	FASTCALL pDecDegree (vec3_t org, float dec, float scale, qBool lod);
float	FASTCALL pIncDegree (vec3_t org, float inc, float scale, qBool lod);

void	CG_ClearParticles (void);
void	CG_AddParticles (void);

//
// GENERIC EFFECTS
//

void CG_BlasterBlueParticles (vec3_t org, vec3_t dir);
void CG_BlasterGoldParticles (vec3_t org, vec3_t dir);
void CG_BlasterGreenParticles (vec3_t org, vec3_t dir);
void CG_BlasterGreyParticles (vec3_t org, vec3_t dir);
void CG_BleedEffect (vec3_t org, vec3_t dir, int count);
void CG_BleedGreenEffect (vec3_t org, vec3_t dir, int count);
void CG_BubbleEffect (vec3_t origin);
void CG_ExplosionBFGEffect (vec3_t org);
void FASTCALL CG_FlareEffect (vec3_t origin, int type, double orient, double size, double sizevel, int color, int colorvel, double alpha, double alphavel);
void CG_ItemRespawnEffect (vec3_t org);
void CG_LogoutEffect (vec3_t org, int type);

void FASTCALL CG_ParticleEffect (vec3_t org, vec3_t dir, int color, int count);
void FASTCALL CG_ParticleEffect2 (vec3_t org, vec3_t dir, int color, int count);
void FASTCALL CG_ParticleEffect3 (vec3_t org, vec3_t dir, int color, int count);
void FASTCALL CG_ParticleSmokeEffect (vec3_t org, vec3_t dir, int color, int count, int magnitude);
void FASTCALL CG_RicochetEffect (vec3_t org, vec3_t dir, int count);

void CG_RocketFireParticles (vec3_t org, vec3_t dir);

void FASTCALL CG_SparkEffect (vec3_t org, vec3_t dir, int color, int colorvel, int count, float smokeScale, float lifeScale);
void FASTCALL CG_SplashParticles (vec3_t org, vec3_t dir, int color, int count, qBool glow);
void FASTCALL CG_SplashEffect (vec3_t org, vec3_t dir, int color, int count);

void CG_BigTeleportParticles (vec3_t org);
void CG_BlasterTip (vec3_t start, vec3_t end);
void CG_ExplosionParticles (vec3_t org, double scale, qBool exploonly, qBool inwater);
void CG_ExplosionBFGParticles (vec3_t org);
void CG_ExplosionColorParticles (vec3_t org);
void CG_FlyEffect (cgEntity_t *ent, vec3_t origin);
void CG_ForceWall (vec3_t start, vec3_t end, int color);
void CG_MonsterPlasma_Shell (vec3_t origin);
void CG_PhalanxTip (vec3_t start, vec3_t end);
void CG_TeleportParticles (vec3_t org);
void CG_TeleporterParticles (entityState_t *ent);
void CG_TrackerShell (vec3_t origin);
void CG_TrapParticles (entity_t *ent);
void CG_WidowSplash (vec3_t org);

//
// GLOOM EFFECTS
//

void CG_GloomBlobTip (vec3_t start, vec3_t end);
void CG_GloomDroneEffect (vec3_t org, vec3_t dir);
void CG_GloomEmberTrail (vec3_t start, vec3_t end);
void CG_GloomFlareTrail (vec3_t start, vec3_t end);
void CG_GloomGasEffect (vec3_t origin);
void CG_GloomRepairEffect (vec3_t org, vec3_t dir, int count);
void CG_GloomStingerFire (vec3_t start, vec3_t end, double size, qBool light);

//
// SUSTAINED EFFECTS
//

void FASTCALL CG_ParticleSteamEffect (vec3_t org, vec3_t dir, int color, int count, int magnitude);

void CG_ParseNuke (void);
void CG_ParseSteam (void);
void CG_ParseWidow (void);

void CG_ClearSustains (void);
void CG_AddSustains (void);

//
// TRAIL EFFECTS
//

void FASTCALL CG_BeamTrail (vec3_t start, vec3_t end, int color, double size, double alpha, double alphaVel);
void CG_BfgTrail (entity_t *ent);
void CG_BlasterGoldTrail (vec3_t start, vec3_t end);
void CG_BlasterGreenTrail (vec3_t start, vec3_t end);
void CG_BubbleTrail (vec3_t start, vec3_t end);
void CG_BubbleTrail2 (vec3_t start, vec3_t end, int dist);
void CG_DebugTrail (vec3_t start, vec3_t end);
void CG_FlagTrail (vec3_t start, vec3_t end, int flags);
void CG_GibTrail (vec3_t start, vec3_t end, int flags);
void CG_GrenadeTrail (vec3_t start, vec3_t end);
void CG_Heatbeam (vec3_t start, vec3_t forward);
void CG_IonripperTrail (vec3_t start, vec3_t end);
void CG_QuadTrail (vec3_t start, vec3_t end);
void CG_RailTrail (vec3_t start, vec3_t end);
void CG_RocketTrail (vec3_t start, vec3_t end);
void CG_TagTrail (vec3_t start, vec3_t end);
void CG_TrackerTrail (vec3_t start, vec3_t end);

//
// PARTICLE THINK FUNCTIONS
//

void pBloodDripThink (struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);
void pBloodThink (struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);
void pBounceThink (struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);
void pExploAnimThink (struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);
void pExploWaveThink (struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);
void pFastSmokeThink (struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);
void pFireThink (struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);
void pFireTrailThink (struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);
void pFlareThink (struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);
void pRailSpiralThink (struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);
void pRicochetSparkThink (struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);
void pSlowFireThink (struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);
void pSmokeThink (struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);
void pSparkGrowThink (struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);
void pSplashThink (struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);
void pSplashPlumeThink (struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);
void pSmokeTrailThink (struct cgParticle_s *p, vec3_t org, vec3_t angle, dvec4_t color, double *size, double *orient, double *time);

/*
==================================================================

	SUSTAINED PARTICLE EFFECTS

==================================================================
*/

typedef struct cgSustainPfx_s {
	vec3_t		org;
	vec3_t		dir;

	int			id;
	int			type;

	int			endtime;
	int			nextthink;
	int			thinkinterval;

	int			color;
	int			count;
	int			magnitude;

	void		(*think)(struct cgSustainPfx_s *self);
} cgSustainPfx_t;

/*
==================================================================

	CONSOLE VARIABLES

==================================================================
*/

extern cVar_t	*cg_mapeffects;

extern cVar_t	*cl_add_decals;
extern cVar_t	*cl_decal_burnlife;
extern cVar_t	*cl_decal_life;
extern cVar_t	*cl_decal_lod;
extern cVar_t	*cl_decal_max;

extern cVar_t	*cl_explorattle;
extern cVar_t	*cl_explorattle_scale;
extern cVar_t	*cl_footsteps;
extern cVar_t	*cl_gun;
extern cVar_t	*cl_noskins;
extern cVar_t	*cl_predict;
extern cVar_t	*cl_showmiss;
extern cVar_t	*cl_vwep;

extern cVar_t	*crosshair;

extern cVar_t	*gender_auto;
extern cVar_t	*gender;
extern cVar_t	*hand;
extern cVar_t	*skin;

extern cVar_t	*glm_advgas;
extern cVar_t	*glm_advstingfire;
extern cVar_t	*glm_blobtype;
extern cVar_t	*glm_bluestingfire;
extern cVar_t	*glm_flashpred;
extern cVar_t	*glm_flwhite;
extern cVar_t	*glm_forcecache;
extern cVar_t	*glm_jumppred;
extern cVar_t	*glm_showclass;

extern cVar_t	*cl_railred;
extern cVar_t	*cl_railgreen;
extern cVar_t	*cl_railblue;
extern cVar_t	*cl_railtrail;
extern cVar_t	*cl_spiralred;
extern cVar_t	*cl_spiralgreen;
extern cVar_t	*cl_spiralblue;

extern cVar_t	*cl_add_particles;
extern cVar_t	*cl_gore;
extern cVar_t	*cl_smokelinger;
extern cVar_t	*part_degree;
extern cVar_t	*part_cull;
extern cVar_t	*part_lod;
extern cVar_t	*part_shade;

extern cVar_t	*r_hudscale;

extern cVar_t	*scr_hudalpha;

/*
==================================================================

	SUPPORTING FUNCTIONS

==================================================================
*/

//
// cg_draw.c
//

void CG_DrawModel (int x, int y, int w, int h, struct model_s *model, struct image_s *skin, vec3_t origin, vec3_t angles);

//
// cg_hud.c
//

void	HUD_CopyLayout (void);
void	HUD_DrawLayout (void);
void	HUD_DrawStatusBar (void);

//
// cg_inventory.c
//

void	Inv_ParseInventory (void);
void	Inv_DrawInventory (void);

//
// cg_main.c
//

char	*CG_StrDup (const char *in);

void	CG_UpdateCvars (void);

void	CG_Init (int playerNum, qBool attractLoop, int vidWidth, int vidHeight);
void	CG_Shutdown (void);

//
// cg_media.c
//

float	palRed (int index);
float	palGreen (int index);
float	palBlue (int index);

float	palRedf (int index);
float	palGreenf (int index);
float	palBluef (int index);

void	CG_InitGloomMedia (void);
void	CG_InitSoundMedia (void);
void	CG_InitMapMedia (void);
void	CG_InitModelMedia (void);
void	CG_InitFXMedia (void);
void	CL_InitCrosshairImage (void);
void	CG_InitPicMedia (void);

void	CG_StartMedia (void);
void	CG_FinishMedia (void);
void	CG_ShutdownMedia (void);

//
// cg_muzzleflash.c
//

void	CG_ParseMuzzleFlash (void);
void	CG_ParseMuzzleFlash2 (void);

//
// cg_players.c
//

extern int		glmClassType;
extern qBool	glmChangePrediction;

extern char	cgWeaponModels[MAX_CLIENTWEAPONMODELS][MAX_QPATH];
extern int	cgNumWeaponModels;

void	CG_LoadClientinfo (clientInfo_t *ci, char *s);

void	CG_FixUpGender (void);

//
// cg_parse.c
//

void	CG_ParseClientinfo (int player);

void	CG_ParseConfigString (int num, char *str);

void	CG_StartServerMessage (void);
void	CG_EndServerMessage (float realTime);
qBool	CG_ParseServerMessage (int command);

//
// cg_screen.c
//

void	SCR_Register (void);

void	SCR_UpdatePING (void);

void	SCR_ParseCenterPrint (void);

void	SCR_Draw (void);

//
// cg_view.c
//

void	V_RenderView (int vidWidth, int vidHeight, int realTime, float frameTime, float stereoSeparation, qBool forceRefresh);

void	V_Register (void);
void	V_Unregister (void);

#endif // __CGAME_LOCAL_H__
